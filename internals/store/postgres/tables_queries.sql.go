// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: tables_queries.sql

package tabmate

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addMemberToTable = `-- name: AddMemberToTable :one
UPDATE tables
SET members = array_append(members, $2), updated_at = NOW()
WHERE id = $1 AND NOT ($2 = ANY(members)) -- Ensure member_id is not already in the array
RETURNING id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at
`

type AddMemberToTableParams struct {
	ID          pgtype.UUID `json:"id"`
	ArrayAppend interface{} `json:"array_append"`
}

// Appends a new member_id to the members array if not already present.
func (q *Queries) AddMemberToTable(ctx context.Context, arg AddMemberToTableParams) (Tables, error) {
	row := q.db.QueryRow(ctx, addMemberToTable, arg.ID, arg.ArrayAppend)
	var i Tables
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.TableCode,
		&i.Name,
		&i.RestaurantName,
		&i.Status,
		&i.MenuUrl,
		&i.Members,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const checkIfTableCodeExists = `-- name: CheckIfTableCodeExists :one
SELECT EXISTS(SELECT 1 FROM tables WHERE table_code = $1)
`

func (q *Queries) CheckIfTableCodeExists(ctx context.Context, tableCode string) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfTableCodeExists, tableCode)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countOpenTables = `-- name: CountOpenTables :one
SELECT COUNT(*) FROM tables
WHERE status = 'open'
`

func (q *Queries) CountOpenTables(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countOpenTables)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTable = `-- name: CreateTable :one
INSERT INTO tables  ( created_by, table_code, name, restaurant_name, status, menu_url, members )
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at
`

type CreateTableParams struct {
	CreatedBy      pgtype.UUID `json:"created_by"`
	TableCode      string      `json:"table_code"`
	Name           pgtype.Text `json:"name"`
	RestaurantName pgtype.Text `json:"restaurant_name"`
	Status         string      `json:"status"`
	MenuUrl        pgtype.Text `json:"menu_url"`
	Members        []int32     `json:"members"`
}

func (q *Queries) CreateTable(ctx context.Context, arg CreateTableParams) (Tables, error) {
	row := q.db.QueryRow(ctx, createTable,
		arg.CreatedBy,
		arg.TableCode,
		arg.Name,
		arg.RestaurantName,
		arg.Status,
		arg.MenuUrl,
		arg.Members,
	)
	var i Tables
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.TableCode,
		&i.Name,
		&i.RestaurantName,
		&i.Status,
		&i.MenuUrl,
		&i.Members,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const deleteTableByCode = `-- name: DeleteTableByCode :exec
DELETE FROM tables
WHERE table_code = $1
`

func (q *Queries) DeleteTableByCode(ctx context.Context, tableCode string) error {
	_, err := q.db.Exec(ctx, deleteTableByCode, tableCode)
	return err
}

const deleteTableByID = `-- name: DeleteTableByID :exec
DELETE FROM tables
WHERE id = $1
`

func (q *Queries) DeleteTableByID(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTableByID, id)
	return err
}

const getAllTableCodes = `-- name: GetAllTableCodes :many
SELECT table_code FROM tables
`

func (q *Queries) GetAllTableCodes(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllTableCodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var table_code string
		if err := rows.Scan(&table_code); err != nil {
			return nil, err
		}
		items = append(items, table_code)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTableByCode = `-- name: GetTableByCode :one
SELECT id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at FROM tables
WHERE table_code = $1
`

func (q *Queries) GetTableByCode(ctx context.Context, tableCode string) (Tables, error) {
	row := q.db.QueryRow(ctx, getTableByCode, tableCode)
	var i Tables
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.TableCode,
		&i.Name,
		&i.RestaurantName,
		&i.Status,
		&i.MenuUrl,
		&i.Members,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const getTableByID = `-- name: GetTableByID :one
SELECT id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at FROM tables
WHERE id = $1
`

func (q *Queries) GetTableByID(ctx context.Context, id pgtype.UUID) (Tables, error) {
	row := q.db.QueryRow(ctx, getTableByID, id)
	var i Tables
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.TableCode,
		&i.Name,
		&i.RestaurantName,
		&i.Status,
		&i.MenuUrl,
		&i.Members,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const listOpenTablesForMember = `-- name: ListOpenTablesForMember :many
SELECT id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at FROM tables
WHERE status = 'open' AND $1 = ANY(members) -- $1 is the user_id to search for
ORDER BY created_at DESC
`

// Finds open tables where the given user ID is a member of the 'members' array.
// Requires a GIN index on 'members' for good performance on large tables.
func (q *Queries) ListOpenTablesForMember(ctx context.Context, members []int32) ([]Tables, error) {
	rows, err := q.db.Query(ctx, listOpenTablesForMember, members)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tables{}
	for rows.Next() {
		var i Tables
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.TableCode,
			&i.Name,
			&i.RestaurantName,
			&i.Status,
			&i.MenuUrl,
			&i.Members,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTablesByStatus = `-- name: ListTablesByStatus :many
SELECT id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at FROM tables
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) ListTablesByStatus(ctx context.Context, status string) ([]Tables, error) {
	rows, err := q.db.Query(ctx, listTablesByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tables{}
	for rows.Next() {
		var i Tables
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.TableCode,
			&i.Name,
			&i.RestaurantName,
			&i.Status,
			&i.MenuUrl,
			&i.Members,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTablesByUserID = `-- name: ListTablesByUserID :many
SELECT id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at FROM tables
WHERE created_by = $1
ORDER BY created_at DESC
`

func (q *Queries) ListTablesByUserID(ctx context.Context, createdBy pgtype.UUID) ([]Tables, error) {
	rows, err := q.db.Query(ctx, listTablesByUserID, createdBy)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tables{}
	for rows.Next() {
		var i Tables
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.TableCode,
			&i.Name,
			&i.RestaurantName,
			&i.Status,
			&i.MenuUrl,
			&i.Members,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMemberFromTable = `-- name: RemoveMemberFromTable :one
UPDATE tables
SET members = array_remove(members, $2), updated_at = NOW()
WHERE id = $1
RETURNING id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at
`

type RemoveMemberFromTableParams struct {
	ID          pgtype.UUID `json:"id"`
	ArrayRemove interface{} `json:"array_remove"`
}

// Removes a specific member_id from the members array.
func (q *Queries) RemoveMemberFromTable(ctx context.Context, arg RemoveMemberFromTableParams) (Tables, error) {
	row := q.db.QueryRow(ctx, removeMemberFromTable, arg.ID, arg.ArrayRemove)
	var i Tables
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.TableCode,
		&i.Name,
		&i.RestaurantName,
		&i.Status,
		&i.MenuUrl,
		&i.Members,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const searchTablesByNameOrRestaurant = `-- name: SearchTablesByNameOrRestaurant :many
SELECT id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at FROM tables
WHERE
    (name ILIKE '%' || $1 || '%' OR restaurant_name ILIKE '%' || $1 || '%')
    AND status = 'open' 
ORDER BY created_at DESC
`

func (q *Queries) SearchTablesByNameOrRestaurant(ctx context.Context, dollar_1 pgtype.Text) ([]Tables, error) {
	rows, err := q.db.Query(ctx, searchTablesByNameOrRestaurant, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Tables{}
	for rows.Next() {
		var i Tables
		if err := rows.Scan(
			&i.ID,
			&i.CreatedBy,
			&i.TableCode,
			&i.Name,
			&i.RestaurantName,
			&i.Status,
			&i.MenuUrl,
			&i.Members,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ClosedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTableMenuURL = `-- name: UpdateTableMenuURL :one
UPDATE tables
SET menu_url = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at
`

type UpdateTableMenuURLParams struct {
	ID      pgtype.UUID `json:"id"`
	MenuUrl pgtype.Text `json:"menu_url"`
}

func (q *Queries) UpdateTableMenuURL(ctx context.Context, arg UpdateTableMenuURLParams) (Tables, error) {
	row := q.db.QueryRow(ctx, updateTableMenuURL, arg.ID, arg.MenuUrl)
	var i Tables
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.TableCode,
		&i.Name,
		&i.RestaurantName,
		&i.Status,
		&i.MenuUrl,
		&i.Members,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const updateTableName = `-- name: UpdateTableName :one
UPDATE tables
SET name = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at
`

type UpdateTableNameParams struct {
	ID   pgtype.UUID `json:"id"`
	Name pgtype.Text `json:"name"`
}

func (q *Queries) UpdateTableName(ctx context.Context, arg UpdateTableNameParams) (Tables, error) {
	row := q.db.QueryRow(ctx, updateTableName, arg.ID, arg.Name)
	var i Tables
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.TableCode,
		&i.Name,
		&i.RestaurantName,
		&i.Status,
		&i.MenuUrl,
		&i.Members,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const updateTableRestaurantName = `-- name: UpdateTableRestaurantName :one
UPDATE tables
SET restaurant_name = $2, updated_at = NOW()
WHERE id = $1
RETURNING id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at
`

type UpdateTableRestaurantNameParams struct {
	ID             pgtype.UUID `json:"id"`
	RestaurantName pgtype.Text `json:"restaurant_name"`
}

func (q *Queries) UpdateTableRestaurantName(ctx context.Context, arg UpdateTableRestaurantNameParams) (Tables, error) {
	row := q.db.QueryRow(ctx, updateTableRestaurantName, arg.ID, arg.RestaurantName)
	var i Tables
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.TableCode,
		&i.Name,
		&i.RestaurantName,
		&i.Status,
		&i.MenuUrl,
		&i.Members,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const updateTableStatus = `-- name: UpdateTableStatus :one
UPDATE tables
SET
    status = $2,
    closed_at = CASE WHEN $2 IN ('closed', 'paid') THEN NOW() ELSE closed_at END, -- Set closed_at if status changes to closed/paid
    updated_at = NOW()
WHERE id = $1
RETURNING id, created_by, table_code, name, restaurant_name, status, menu_url, members, created_at, updated_at, closed_at
`

type UpdateTableStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateTableStatus(ctx context.Context, arg UpdateTableStatusParams) (Tables, error) {
	row := q.db.QueryRow(ctx, updateTableStatus, arg.ID, arg.Status)
	var i Tables
	err := row.Scan(
		&i.ID,
		&i.CreatedBy,
		&i.TableCode,
		&i.Name,
		&i.RestaurantName,
		&i.Status,
		&i.MenuUrl,
		&i.Members,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}
