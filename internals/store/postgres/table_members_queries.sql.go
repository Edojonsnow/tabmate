// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: table_members_queries.sql

package tabmate

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToTable = `-- name: AddUserToTable :one
INSERT INTO table_members (
    table_id,
    user_id,
    role
    -- joined_at and is_settled will use their DEFAULT values
) VALUES (
    $1, $2, $3
)
RETURNING table_id, user_id, joined_at, role, is_settled
`

type AddUserToTableParams struct {
	TableID pgtype.UUID `json:"table_id"`
	UserID  pgtype.UUID `json:"user_id"`
	Role    string      `json:"role"`
}

// Adds a user to a table with an optional role, defaulting is_settled to false.
func (q *Queries) AddUserToTable(ctx context.Context, arg AddUserToTableParams) (TableMembers, error) {
	row := q.db.QueryRow(ctx, addUserToTable, arg.TableID, arg.UserID, arg.Role)
	var i TableMembers
	err := row.Scan(
		&i.TableID,
		&i.UserID,
		&i.JoinedAt,
		&i.Role,
		&i.IsSettled,
	)
	return i, err
}

const checkIfUserIsMember = `-- name: CheckIfUserIsMember :one
SELECT EXISTS(
    SELECT 1 FROM table_members
    WHERE table_id = $1 AND user_id = $2
)
`

type CheckIfUserIsMemberParams struct {
	TableID pgtype.UUID `json:"table_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

// Checks if a specific user is a member of a specific table.
func (q *Queries) CheckIfUserIsMember(ctx context.Context, arg CheckIfUserIsMemberParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkIfUserIsMember, arg.TableID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countMembersInTable = `-- name: CountMembersInTable :one
SELECT COUNT(*) FROM table_members
WHERE table_id = $1
`

// Counts the number of members in a specific table.
func (q *Queries) CountMembersInTable(ctx context.Context, tableID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countMembersInTable, tableID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMemberRoleInTable = `-- name: GetMemberRoleInTable :one

SELECT role FROM table_members
WHERE table_id = $1 AND user_id = $2
`

type GetMemberRoleInTableParams struct {
	TableID pgtype.UUID `json:"table_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

// -- name: ListTablesByUserID :many
// -- Retrieves all membership records for a specific user_id.
// SELECT * FROM table_members
// WHERE user_id = $1
// ORDER BY joined_at DESC;
// Retrieves the role of a specific user in a specific table.
func (q *Queries) GetMemberRoleInTable(ctx context.Context, arg GetMemberRoleInTableParams) (string, error) {
	row := q.db.QueryRow(ctx, getMemberRoleInTable, arg.TableID, arg.UserID)
	var role string
	err := row.Scan(&role)
	return role, err
}

const getTableMember = `-- name: GetTableMember :one
SELECT table_id, user_id, joined_at, role, is_settled FROM table_members
WHERE table_id = $1 AND user_id = $2
`

type GetTableMemberParams struct {
	TableID pgtype.UUID `json:"table_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

// Retrieves a specific membership record by table_id and user_id.
func (q *Queries) GetTableMember(ctx context.Context, arg GetTableMemberParams) (TableMembers, error) {
	row := q.db.QueryRow(ctx, getTableMember, arg.TableID, arg.UserID)
	var i TableMembers
	err := row.Scan(
		&i.TableID,
		&i.UserID,
		&i.JoinedAt,
		&i.Role,
		&i.IsSettled,
	)
	return i, err
}

const getTableMembershipDetailsForUser = `-- name: GetTableMembershipDetailsForUser :many
SELECT table_id, user_id, joined_at, role, is_settled FROM table_members
WHERE user_id = $1
ORDER BY table_id, joined_at DESC
`

// Retrieves all membership details for a specific user across all tables.
func (q *Queries) GetTableMembershipDetailsForUser(ctx context.Context, userID pgtype.UUID) ([]TableMembers, error) {
	rows, err := q.db.Query(ctx, getTableMembershipDetailsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableMembers{}
	for rows.Next() {
		var i TableMembers
		if err := rows.Scan(
			&i.TableID,
			&i.UserID,
			&i.JoinedAt,
			&i.Role,
			&i.IsSettled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembersByTableID = `-- name: ListMembersByTableID :many
SELECT table_id, user_id, joined_at, role, is_settled FROM table_members
WHERE table_id = $1
ORDER BY joined_at ASC
`

// Retrieves all membership records for a specific table_id.
func (q *Queries) ListMembersByTableID(ctx context.Context, tableID pgtype.UUID) ([]TableMembers, error) {
	rows, err := q.db.Query(ctx, listMembersByTableID, tableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableMembers{}
	for rows.Next() {
		var i TableMembers
		if err := rows.Scan(
			&i.TableID,
			&i.UserID,
			&i.JoinedAt,
			&i.Role,
			&i.IsSettled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMembersWithUserDetailsByTableID = `-- name: ListMembersWithUserDetailsByTableID :many
SELECT
    tm.table_id,
    tm.user_id,
    tm.joined_at,
    tm.role,
    tm.is_settled,
    u.email AS user_email,
    u.name AS user_name,
    u.profile_picture_url AS user_profile_picture_url
FROM table_members tm
JOIN users u ON tm.user_id = u.id
WHERE tm.table_id = $1
ORDER BY tm.joined_at ASC
`

type ListMembersWithUserDetailsByTableIDRow struct {
	TableID               pgtype.UUID        `json:"table_id"`
	UserID                pgtype.UUID        `json:"user_id"`
	JoinedAt              pgtype.Timestamptz `json:"joined_at"`
	Role                  string             `json:"role"`
	IsSettled             bool               `json:"is_settled"`
	UserEmail             string             `json:"user_email"`
	UserName              pgtype.Text        `json:"user_name"`
	UserProfilePictureUrl pgtype.Text        `json:"user_profile_picture_url"`
}

// Retrieves all members of a specific table_id and include their user details.
func (q *Queries) ListMembersWithUserDetailsByTableID(ctx context.Context, tableID pgtype.UUID) ([]ListMembersWithUserDetailsByTableIDRow, error) {
	rows, err := q.db.Query(ctx, listMembersWithUserDetailsByTableID, tableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMembersWithUserDetailsByTableIDRow{}
	for rows.Next() {
		var i ListMembersWithUserDetailsByTableIDRow
		if err := rows.Scan(
			&i.TableID,
			&i.UserID,
			&i.JoinedAt,
			&i.Role,
			&i.IsSettled,
			&i.UserEmail,
			&i.UserName,
			&i.UserProfilePictureUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSettledMembersInTable = `-- name: ListSettledMembersInTable :many
SELECT table_id, user_id, joined_at, role, is_settled FROM table_members
WHERE table_id = $1 AND is_settled = TRUE
ORDER BY joined_at ASC
`

// Retrieves all members of a table_id where is_settled is true.
func (q *Queries) ListSettledMembersInTable(ctx context.Context, tableID pgtype.UUID) ([]TableMembers, error) {
	rows, err := q.db.Query(ctx, listSettledMembersInTable, tableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableMembers{}
	for rows.Next() {
		var i TableMembers
		if err := rows.Scan(
			&i.TableID,
			&i.UserID,
			&i.JoinedAt,
			&i.Role,
			&i.IsSettled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTablesWithMembershipStatusForUser = `-- name: ListTablesWithMembershipStatusForUser :many
SELECT
    t.id AS table_id,
    t.table_code,
    t.name AS table_name,
    t.restaurant_name,
    t.status AS table_status,
    t.vat,
    t.created_by as table_host,
    tm.role AS user_role_in_table,
    tm.is_settled AS user_is_settled_in_table,
    tm.joined_at,
    COALESCE(SUM(i.price * i.quantity), 0) AS total_items_price -- Sums (item price * quantity) for each table
FROM table_members tm
JOIN tables t ON tm.table_id = t.id
LEFT JOIN items i ON i.table_code = t.table_code  -- Join items for each table
WHERE tm.user_id = $1
GROUP BY
    t.id,
    t.table_code,
    t.name,
    t.restaurant_name,
    t.status,
    tm.role,
    tm.is_settled,
    tm.joined_at
ORDER BY t.created_at DESC, tm.joined_at DESC
`

type ListTablesWithMembershipStatusForUserRow struct {
	TableID              pgtype.UUID        `json:"table_id"`
	TableCode            string             `json:"table_code"`
	TableName            pgtype.Text        `json:"table_name"`
	RestaurantName       pgtype.Text        `json:"restaurant_name"`
	TableStatus          string             `json:"table_status"`
	Vat                  pgtype.Numeric     `json:"vat"`
	TableHost            pgtype.UUID        `json:"table_host"`
	UserRoleInTable      string             `json:"user_role_in_table"`
	UserIsSettledInTable bool               `json:"user_is_settled_in_table"`
	JoinedAt             pgtype.Timestamptz `json:"joined_at"`
	TotalItemsPrice      interface{}        `json:"total_items_price"`
}

// For a specific user, list all tables they are a member of,
// along with their role and is_settled status in each, and table details.
func (q *Queries) ListTablesWithMembershipStatusForUser(ctx context.Context, userID pgtype.UUID) ([]ListTablesWithMembershipStatusForUserRow, error) {
	rows, err := q.db.Query(ctx, listTablesWithMembershipStatusForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListTablesWithMembershipStatusForUserRow{}
	for rows.Next() {
		var i ListTablesWithMembershipStatusForUserRow
		if err := rows.Scan(
			&i.TableID,
			&i.TableCode,
			&i.TableName,
			&i.RestaurantName,
			&i.TableStatus,
			&i.Vat,
			&i.TableHost,
			&i.UserRoleInTable,
			&i.UserIsSettledInTable,
			&i.JoinedAt,
			&i.TotalItemsPrice,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnsettledMembersInTable = `-- name: ListUnsettledMembersInTable :many
SELECT table_id, user_id, joined_at, role, is_settled FROM table_members
WHERE table_id = $1 AND is_settled = FALSE
ORDER BY joined_at ASC
`

// Retrieves all members of a table_id where is_settled is false.
func (q *Queries) ListUnsettledMembersInTable(ctx context.Context, tableID pgtype.UUID) ([]TableMembers, error) {
	rows, err := q.db.Query(ctx, listUnsettledMembersInTable, tableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableMembers{}
	for rows.Next() {
		var i TableMembers
		if err := rows.Scan(
			&i.TableID,
			&i.UserID,
			&i.JoinedAt,
			&i.Role,
			&i.IsSettled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markAllMembersInTableAsSettled = `-- name: MarkAllMembersInTableAsSettled :many
UPDATE table_members
SET is_settled = TRUE
WHERE table_id = $1
RETURNING table_id, user_id, joined_at, role, is_settled
`

// Sets is_settled to true for all members of a specific table.
// Returns all updated member rows.
func (q *Queries) MarkAllMembersInTableAsSettled(ctx context.Context, tableID pgtype.UUID) ([]TableMembers, error) {
	rows, err := q.db.Query(ctx, markAllMembersInTableAsSettled, tableID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TableMembers{}
	for rows.Next() {
		var i TableMembers
		if err := rows.Scan(
			&i.TableID,
			&i.UserID,
			&i.JoinedAt,
			&i.Role,
			&i.IsSettled,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromTable = `-- name: RemoveUserFromTable :exec
DELETE FROM table_members
WHERE table_id = $1 AND user_id = $2
`

type RemoveUserFromTableParams struct {
	TableID pgtype.UUID `json:"table_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

// Removes a user from a specific table.
func (q *Queries) RemoveUserFromTable(ctx context.Context, arg RemoveUserFromTableParams) error {
	_, err := q.db.Exec(ctx, removeUserFromTable, arg.TableID, arg.UserID)
	return err
}

const setMemberSettledStatus = `-- name: SetMemberSettledStatus :one
UPDATE table_members
SET is_settled = $3
WHERE table_id = $1 AND user_id = $2
RETURNING table_id, user_id, joined_at, role, is_settled
`

type SetMemberSettledStatusParams struct {
	TableID   pgtype.UUID `json:"table_id"`
	UserID    pgtype.UUID `json:"user_id"`
	IsSettled bool        `json:"is_settled"`
}

// Updates the is_settled status for a user in a specific table.
func (q *Queries) SetMemberSettledStatus(ctx context.Context, arg SetMemberSettledStatusParams) (TableMembers, error) {
	row := q.db.QueryRow(ctx, setMemberSettledStatus, arg.TableID, arg.UserID, arg.IsSettled)
	var i TableMembers
	err := row.Scan(
		&i.TableID,
		&i.UserID,
		&i.JoinedAt,
		&i.Role,
		&i.IsSettled,
	)
	return i, err
}

const updateMemberRoleInTable = `-- name: UpdateMemberRoleInTable :one
UPDATE table_members
SET role = $3
WHERE table_id = $1 AND user_id = $2
RETURNING table_id, user_id, joined_at, role, is_settled
`

type UpdateMemberRoleInTableParams struct {
	TableID pgtype.UUID `json:"table_id"`
	UserID  pgtype.UUID `json:"user_id"`
	Role    string      `json:"role"`
}

// Updates the role of a user within a specific table.
func (q *Queries) UpdateMemberRoleInTable(ctx context.Context, arg UpdateMemberRoleInTableParams) (TableMembers, error) {
	row := q.db.QueryRow(ctx, updateMemberRoleInTable, arg.TableID, arg.UserID, arg.Role)
	var i TableMembers
	err := row.Scan(
		&i.TableID,
		&i.UserID,
		&i.JoinedAt,
		&i.Role,
		&i.IsSettled,
	)
	return i, err
}
