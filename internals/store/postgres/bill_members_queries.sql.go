// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: bill_members_queries.sql

package tabmate

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToBill = `-- name: AddUserToBill :one
INSERT INTO bill_members (bill_id, user_id, amount_owed, role)
VALUES ($1, $2, $3, $4)
RETURNING bill_id, user_id, amount_owed, is_settled, settled_at, role, joined_at
`

type AddUserToBillParams struct {
	BillID     pgtype.UUID    `json:"bill_id"`
	UserID     pgtype.UUID    `json:"user_id"`
	AmountOwed pgtype.Numeric `json:"amount_owed"`
	Role       string         `json:"role"`
}

func (q *Queries) AddUserToBill(ctx context.Context, arg AddUserToBillParams) (BillMembers, error) {
	row := q.db.QueryRow(ctx, addUserToBill,
		arg.BillID,
		arg.UserID,
		arg.AmountOwed,
		arg.Role,
	)
	var i BillMembers
	err := row.Scan(
		&i.BillID,
		&i.UserID,
		&i.AmountOwed,
		&i.IsSettled,
		&i.SettledAt,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const countUnsettledBillMembers = `-- name: CountUnsettledBillMembers :one
SELECT COUNT(*) FROM bill_members
WHERE bill_id = $1 AND is_settled = FALSE
`

func (q *Queries) CountUnsettledBillMembers(ctx context.Context, billID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUnsettledBillMembers, billID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getBillMember = `-- name: GetBillMember :one
SELECT bill_id, user_id, amount_owed, is_settled, settled_at, role, joined_at FROM bill_members
WHERE bill_id = $1 AND user_id = $2
`

type GetBillMemberParams struct {
	BillID pgtype.UUID `json:"bill_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetBillMember(ctx context.Context, arg GetBillMemberParams) (BillMembers, error) {
	row := q.db.QueryRow(ctx, getBillMember, arg.BillID, arg.UserID)
	var i BillMembers
	err := row.Scan(
		&i.BillID,
		&i.UserID,
		&i.AmountOwed,
		&i.IsSettled,
		&i.SettledAt,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}

const listBillMembersByBillID = `-- name: ListBillMembersByBillID :many
SELECT bill_id, user_id, amount_owed, is_settled, settled_at, role, joined_at FROM bill_members
WHERE bill_id = $1
ORDER BY joined_at ASC
`

func (q *Queries) ListBillMembersByBillID(ctx context.Context, billID pgtype.UUID) ([]BillMembers, error) {
	rows, err := q.db.Query(ctx, listBillMembersByBillID, billID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []BillMembers{}
	for rows.Next() {
		var i BillMembers
		if err := rows.Scan(
			&i.BillID,
			&i.UserID,
			&i.AmountOwed,
			&i.IsSettled,
			&i.SettledAt,
			&i.Role,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBillMembersWithUserDetails = `-- name: ListBillMembersWithUserDetails :many
SELECT
    bm.bill_id,
    bm.user_id,
    bm.amount_owed,
    bm.is_settled,
    bm.settled_at,
    bm.role,
    bm.joined_at,
    u.email AS user_email,
    u.name AS user_name,
    u.profile_picture_url AS user_profile_picture_url
FROM bill_members bm
JOIN users u ON bm.user_id = u.id
WHERE bm.bill_id = $1
ORDER BY bm.joined_at ASC
`

type ListBillMembersWithUserDetailsRow struct {
	BillID                pgtype.UUID        `json:"bill_id"`
	UserID                pgtype.UUID        `json:"user_id"`
	AmountOwed            pgtype.Numeric     `json:"amount_owed"`
	IsSettled             bool               `json:"is_settled"`
	SettledAt             pgtype.Timestamptz `json:"settled_at"`
	Role                  string             `json:"role"`
	JoinedAt              pgtype.Timestamptz `json:"joined_at"`
	UserEmail             string             `json:"user_email"`
	UserName              pgtype.Text        `json:"user_name"`
	UserProfilePictureUrl pgtype.Text        `json:"user_profile_picture_url"`
}

// Get all members of a bill with their user info
func (q *Queries) ListBillMembersWithUserDetails(ctx context.Context, billID pgtype.UUID) ([]ListBillMembersWithUserDetailsRow, error) {
	rows, err := q.db.Query(ctx, listBillMembersWithUserDetails, billID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBillMembersWithUserDetailsRow{}
	for rows.Next() {
		var i ListBillMembersWithUserDetailsRow
		if err := rows.Scan(
			&i.BillID,
			&i.UserID,
			&i.AmountOwed,
			&i.IsSettled,
			&i.SettledAt,
			&i.Role,
			&i.JoinedAt,
			&i.UserEmail,
			&i.UserName,
			&i.UserProfilePictureUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBillsForUser = `-- name: ListBillsForUser :many
SELECT
    fb.id AS bill_id,
    fb.bill_code,
    fb.name AS bill_name,
    fb.total_amount,
    fb.status AS bill_status,
    fb.created_by as bill_creator,
    bm.role AS user_role_in_bill,
    bm.amount_owed,
    bm.is_settled AS user_is_settled,
    bm.joined_at
FROM bill_members bm
JOIN fixedbills fb ON bm.bill_id = fb.id
WHERE bm.user_id = $1
ORDER BY fb.created_at DESC
`

type ListBillsForUserRow struct {
	BillID         pgtype.UUID        `json:"bill_id"`
	BillCode       string             `json:"bill_code"`
	BillName       string             `json:"bill_name"`
	TotalAmount    pgtype.Numeric     `json:"total_amount"`
	BillStatus     string             `json:"bill_status"`
	BillCreator    pgtype.UUID        `json:"bill_creator"`
	UserRoleInBill string             `json:"user_role_in_bill"`
	AmountOwed     pgtype.Numeric     `json:"amount_owed"`
	UserIsSettled  bool               `json:"user_is_settled"`
	JoinedAt       pgtype.Timestamptz `json:"joined_at"`
}

// Get all bills a user is a member of
func (q *Queries) ListBillsForUser(ctx context.Context, userID pgtype.UUID) ([]ListBillsForUserRow, error) {
	rows, err := q.db.Query(ctx, listBillsForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListBillsForUserRow{}
	for rows.Next() {
		var i ListBillsForUserRow
		if err := rows.Scan(
			&i.BillID,
			&i.BillCode,
			&i.BillName,
			&i.TotalAmount,
			&i.BillStatus,
			&i.BillCreator,
			&i.UserRoleInBill,
			&i.AmountOwed,
			&i.UserIsSettled,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recalculateBillSplitForAllMembers = `-- name: RecalculateBillSplitForAllMembers :exec
UPDATE bill_members bm
SET amount_owed = (
    SELECT fb.total_amount / COUNT(*)
    FROM bill_members bm2
    WHERE bm2.bill_id = bm.bill_id
)
FROM fixedbills fb
WHERE bm.bill_id = fb.id AND bm.bill_id = $1
`

// When someone joins/leaves, recalculate everyone's amount_owed
func (q *Queries) RecalculateBillSplitForAllMembers(ctx context.Context, billID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, recalculateBillSplitForAllMembers, billID)
	return err
}

const removeUserFromBill = `-- name: RemoveUserFromBill :exec
DELETE FROM bill_members
WHERE bill_id = $1 AND user_id = $2
`

type RemoveUserFromBillParams struct {
	BillID pgtype.UUID `json:"bill_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) RemoveUserFromBill(ctx context.Context, arg RemoveUserFromBillParams) error {
	_, err := q.db.Exec(ctx, removeUserFromBill, arg.BillID, arg.UserID)
	return err
}

const updateBillMemberSettledStatus = `-- name: UpdateBillMemberSettledStatus :one
UPDATE bill_members
SET 
    is_settled = $3,
    settled_at = CASE WHEN $3 = TRUE THEN NOW() ELSE NULL END
WHERE bill_id = $1 AND user_id = $2
RETURNING bill_id, user_id, amount_owed, is_settled, settled_at, role, joined_at
`

type UpdateBillMemberSettledStatusParams struct {
	BillID    pgtype.UUID `json:"bill_id"`
	UserID    pgtype.UUID `json:"user_id"`
	IsSettled bool        `json:"is_settled"`
}

func (q *Queries) UpdateBillMemberSettledStatus(ctx context.Context, arg UpdateBillMemberSettledStatusParams) (BillMembers, error) {
	row := q.db.QueryRow(ctx, updateBillMemberSettledStatus, arg.BillID, arg.UserID, arg.IsSettled)
	var i BillMembers
	err := row.Scan(
		&i.BillID,
		&i.UserID,
		&i.AmountOwed,
		&i.IsSettled,
		&i.SettledAt,
		&i.Role,
		&i.JoinedAt,
	)
	return i, err
}
